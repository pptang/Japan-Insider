-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Wordpress.Query exposing (CategoriesOptionalArguments, CategoryRequiredArguments, CommentRequiredArguments, CommentsOptionalArguments, MediaItemByOptionalArguments, MediaItemRequiredArguments, MediaItemsOptionalArguments, MenuItemRequiredArguments, MenuItemsOptionalArguments, MenuRequiredArguments, MenusOptionalArguments, NodeRequiredArguments, PageByOptionalArguments, PageRequiredArguments, PagesOptionalArguments, PluginRequiredArguments, PluginsOptionalArguments, PostByOptionalArguments, PostRequiredArguments, PostsOptionalArguments, RevisionByOptionalArguments, RevisionRequiredArguments, RevisionsOptionalArguments, TagRequiredArguments, TagsOptionalArguments, ThemeRequiredArguments, ThemesOptionalArguments, UserRequiredArguments, UserRoleRequiredArguments, UserRolesOptionalArguments, UsersOptionalArguments, allSettings, categories, category, comment, comments, discussionSettings, generalSettings, headerMenu, mediaItem, mediaItemBy, mediaItems, menu, menuItem, menuItems, menus, node, page, pageBy, pages, plugin, plugins, post, postBy, posts, readingSettings, revision, revisionBy, revisions, tag, tags, theme, themes, user, userRole, userRoles, users, viewer, writingSettings)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import Wordpress.InputObject
import Wordpress.Interface
import Wordpress.Object
import Wordpress.Scalar
import Wordpress.ScalarCodecs
import Wordpress.Union


{-| Entry point to get all settings for the site
-}
allSettings : SelectionSet decodesTo Wordpress.Object.Settings -> SelectionSet (Maybe decodesTo) RootQuery
allSettings object_ =
    Object.selectionForCompositeField "allSettings" [] object_ (identity >> Decode.nullable)


type alias CategoriesOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToCategoryConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
categories : (CategoriesOptionalArguments -> CategoriesOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToCategoryConnection -> SelectionSet (Maybe decodesTo) RootQuery
categories fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToCategoryConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "categories" optionalArgs object_ (identity >> Decode.nullable)


type alias CategoryRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A 0bject
-}
category : CategoryRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Category -> SelectionSet (Maybe decodesTo) RootQuery
category requiredArgs object_ =
    Object.selectionForCompositeField "category" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias CommentRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| Returns a Comment
-}
comment : CommentRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Comment -> SelectionSet (Maybe decodesTo) RootQuery
comment requiredArgs object_ =
    Object.selectionForCompositeField "comment" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias CommentsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToCommentConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
comments : (CommentsOptionalArguments -> CommentsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToCommentConnection -> SelectionSet (Maybe decodesTo) RootQuery
comments fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToCommentConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "comments" optionalArgs object_ (identity >> Decode.nullable)


{-| -}
discussionSettings : SelectionSet decodesTo Wordpress.Object.DiscussionSettings -> SelectionSet (Maybe decodesTo) RootQuery
discussionSettings object_ =
    Object.selectionForCompositeField "discussionSettings" [] object_ (identity >> Decode.nullable)


{-| -}
generalSettings : SelectionSet decodesTo Wordpress.Object.GeneralSettings -> SelectionSet (Maybe decodesTo) RootQuery
generalSettings object_ =
    Object.selectionForCompositeField "generalSettings" [] object_ (identity >> Decode.nullable)


{-| Returns the header menu items
-}
headerMenu : SelectionSet decodesTo Wordpress.Object.HeaderMenuType -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
headerMenu object_ =
    Object.selectionForCompositeField "headerMenu" [] object_ (identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias MediaItemRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A 0bject
-}
mediaItem : MediaItemRequiredArguments -> SelectionSet decodesTo Wordpress.Object.MediaItem -> SelectionSet (Maybe decodesTo) RootQuery
mediaItem requiredArgs object_ =
    Object.selectionForCompositeField "mediaItem" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias MediaItemByOptionalArguments =
    { id : OptionalArgument Wordpress.ScalarCodecs.Id
    , mediaItemId : OptionalArgument Int
    , uri : OptionalArgument String
    , slug : OptionalArgument String
    }


{-| A mediaItem object

  - id - Get the object by its global ID
  - mediaItemId - Get the mediaItem by its database ID
  - uri - Get the mediaItem by its uri
  - slug - Get the mediaItem by its slug (only available for non-hierarchical types)

-}
mediaItemBy : (MediaItemByOptionalArguments -> MediaItemByOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.MediaItem -> SelectionSet (Maybe decodesTo) RootQuery
mediaItemBy fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, mediaItemId = Absent, uri = Absent, slug = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId), Argument.optional "mediaItemId" filledInOptionals.mediaItemId Encode.int, Argument.optional "uri" filledInOptionals.uri Encode.string, Argument.optional "slug" filledInOptionals.slug Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "mediaItemBy" optionalArgs object_ (identity >> Decode.nullable)


type alias MediaItemsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToMediaItemConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
mediaItems : (MediaItemsOptionalArguments -> MediaItemsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToMediaItemConnection -> SelectionSet (Maybe decodesTo) RootQuery
mediaItems fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToMediaItemConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "mediaItems" optionalArgs object_ (identity >> Decode.nullable)


type alias MenuRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A WordPress navigation menu
-}
menu : MenuRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Menu -> SelectionSet (Maybe decodesTo) RootQuery
menu requiredArgs object_ =
    Object.selectionForCompositeField "menu" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias MenuItemsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToMenuItemConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
menuItems : (MenuItemsOptionalArguments -> MenuItemsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToMenuItemConnection -> SelectionSet (Maybe decodesTo) RootQuery
menuItems fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToMenuItemConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "menuItems" optionalArgs object_ (identity >> Decode.nullable)


type alias MenuItemRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A WordPress navigation menu item
-}
menuItem : MenuItemRequiredArguments -> SelectionSet decodesTo Wordpress.Object.MenuItem -> SelectionSet (Maybe decodesTo) RootQuery
menuItem requiredArgs object_ =
    Object.selectionForCompositeField "menuItem" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias MenusOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToMenuConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
menus : (MenusOptionalArguments -> MenusOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToMenuConnection -> SelectionSet (Maybe decodesTo) RootQuery
menus fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToMenuConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "menus" optionalArgs object_ (identity >> Decode.nullable)


type alias NodeRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| Fetches an object given its ID

  - id - The ID of an object

-}
node : NodeRequiredArguments -> SelectionSet decodesTo Wordpress.Interface.Node -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs object_ =
    Object.selectionForCompositeField "node" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias PageRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A 0bject
-}
page : PageRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Page -> SelectionSet (Maybe decodesTo) RootQuery
page requiredArgs object_ =
    Object.selectionForCompositeField "page" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias PageByOptionalArguments =
    { id : OptionalArgument Wordpress.ScalarCodecs.Id
    , pageId : OptionalArgument Int
    , uri : OptionalArgument String
    }


{-| A page object

  - id - Get the object by its global ID
  - pageId - Get the page by its database ID
  - uri - Get the page by its uri

-}
pageBy : (PageByOptionalArguments -> PageByOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.Page -> SelectionSet (Maybe decodesTo) RootQuery
pageBy fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, pageId = Absent, uri = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId), Argument.optional "pageId" filledInOptionals.pageId Encode.int, Argument.optional "uri" filledInOptionals.uri Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pageBy" optionalArgs object_ (identity >> Decode.nullable)


type alias PagesOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToPageConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
pages : (PagesOptionalArguments -> PagesOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToPageConnection -> SelectionSet (Maybe decodesTo) RootQuery
pages fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToPageConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pages" optionalArgs object_ (identity >> Decode.nullable)


type alias PluginRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A WordPress plugin
-}
plugin : PluginRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Plugin -> SelectionSet (Maybe decodesTo) RootQuery
plugin requiredArgs object_ =
    Object.selectionForCompositeField "plugin" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias PluginsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data

-}
plugins : (PluginsOptionalArguments -> PluginsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToPluginConnection -> SelectionSet (Maybe decodesTo) RootQuery
plugins fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "plugins" optionalArgs object_ (identity >> Decode.nullable)


type alias PostRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A 0bject
-}
post : PostRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Post -> SelectionSet (Maybe decodesTo) RootQuery
post requiredArgs object_ =
    Object.selectionForCompositeField "post" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias PostByOptionalArguments =
    { id : OptionalArgument Wordpress.ScalarCodecs.Id
    , postId : OptionalArgument Int
    , uri : OptionalArgument String
    , slug : OptionalArgument String
    }


{-| A post object

  - id - Get the object by its global ID
  - postId - Get the post by its database ID
  - uri - Get the post by its uri
  - slug - Get the post by its slug (only available for non-hierarchical types)

-}
postBy : (PostByOptionalArguments -> PostByOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.Post -> SelectionSet (Maybe decodesTo) RootQuery
postBy fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, postId = Absent, uri = Absent, slug = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId), Argument.optional "postId" filledInOptionals.postId Encode.int, Argument.optional "uri" filledInOptionals.uri Encode.string, Argument.optional "slug" filledInOptionals.slug Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "postBy" optionalArgs object_ (identity >> Decode.nullable)


type alias PostsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToPostConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
posts : (PostsOptionalArguments -> PostsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToPostConnection -> SelectionSet (Maybe decodesTo) RootQuery
posts fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToPostConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "posts" optionalArgs object_ (identity >> Decode.nullable)


{-| -}
readingSettings : SelectionSet decodesTo Wordpress.Object.ReadingSettings -> SelectionSet (Maybe decodesTo) RootQuery
readingSettings object_ =
    Object.selectionForCompositeField "readingSettings" [] object_ (identity >> Decode.nullable)


type alias RevisionRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A 0bject
-}
revision : RevisionRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Revision -> SelectionSet (Maybe decodesTo) RootQuery
revision requiredArgs object_ =
    Object.selectionForCompositeField "revision" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias RevisionByOptionalArguments =
    { id : OptionalArgument Wordpress.ScalarCodecs.Id
    , revisionId : OptionalArgument Int
    , uri : OptionalArgument String
    , slug : OptionalArgument String
    }


{-| A revision object

  - id - Get the object by its global ID
  - revisionId - Get the revision by its database ID
  - uri - Get the revision by its uri
  - slug - Get the revision by its slug (only available for non-hierarchical types)

-}
revisionBy : (RevisionByOptionalArguments -> RevisionByOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.Revision -> SelectionSet (Maybe decodesTo) RootQuery
revisionBy fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, revisionId = Absent, uri = Absent, slug = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId), Argument.optional "revisionId" filledInOptionals.revisionId Encode.int, Argument.optional "uri" filledInOptionals.uri Encode.string, Argument.optional "slug" filledInOptionals.slug Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "revisionBy" optionalArgs object_ (identity >> Decode.nullable)


type alias RevisionsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToRevisionConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
revisions : (RevisionsOptionalArguments -> RevisionsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToRevisionConnection -> SelectionSet (Maybe decodesTo) RootQuery
revisions fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToRevisionConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "revisions" optionalArgs object_ (identity >> Decode.nullable)


type alias TagRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A 0bject
-}
tag : TagRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Tag -> SelectionSet (Maybe decodesTo) RootQuery
tag requiredArgs object_ =
    Object.selectionForCompositeField "tag" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias TagsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToTagConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
tags : (TagsOptionalArguments -> TagsOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToTagConnection -> SelectionSet (Maybe decodesTo) RootQuery
tags fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToTagConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tags" optionalArgs object_ (identity >> Decode.nullable)


type alias ThemeRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| A Theme object
-}
theme : ThemeRequiredArguments -> SelectionSet decodesTo Wordpress.Object.Theme -> SelectionSet (Maybe decodesTo) RootQuery
theme requiredArgs object_ =
    Object.selectionForCompositeField "theme" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias ThemesOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data

-}
themes : (ThemesOptionalArguments -> ThemesOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToThemeConnection -> SelectionSet (Maybe decodesTo) RootQuery
themes fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "themes" optionalArgs object_ (identity >> Decode.nullable)


type alias UserRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| Returns a user
-}
user : UserRequiredArguments -> SelectionSet decodesTo Wordpress.Object.User -> SelectionSet (Maybe decodesTo) RootQuery
user requiredArgs object_ =
    Object.selectionForCompositeField "user" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias UserRolesOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data

-}
userRoles : (UserRolesOptionalArguments -> UserRolesOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToUserRoleConnection -> SelectionSet (Maybe decodesTo) RootQuery
userRoles fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "userRoles" optionalArgs object_ (identity >> Decode.nullable)


type alias UserRoleRequiredArguments =
    { id : Wordpress.ScalarCodecs.Id }


{-| Returns a user role
-}
userRole : UserRoleRequiredArguments -> SelectionSet decodesTo Wordpress.Object.UserRole -> SelectionSet (Maybe decodesTo) RootQuery
userRole requiredArgs object_ =
    Object.selectionForCompositeField "userRole" [ Argument.required "id" requiredArgs.id (Wordpress.ScalarCodecs.codecs |> Wordpress.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias UsersOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , where_ : OptionalArgument Wordpress.InputObject.RootQueryToUserConnectionWhereArgs
    }


{-| Connection between the RootQuery type and the RootQuery type

  - first - The number of items to return after the referenced "after" cursor
  - after - Cursor used along with the "first" argument to reference where in the dataset to get data
  - before - Cursor used along with the "last" argument to reference where in the dataset to get data
  - where\_ - Arguments for filtering the connection

-}
users : (UsersOptionalArguments -> UsersOptionalArguments) -> SelectionSet decodesTo Wordpress.Object.RootQueryToUserConnection -> SelectionSet (Maybe decodesTo) RootQuery
users fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { first = Absent, last = Absent, after = Absent, before = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "where" filledInOptionals.where_ Wordpress.InputObject.encodeRootQueryToUserConnectionWhereArgs ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "users" optionalArgs object_ (identity >> Decode.nullable)


{-| Returns the current user
-}
viewer : SelectionSet decodesTo Wordpress.Object.User -> SelectionSet (Maybe decodesTo) RootQuery
viewer object_ =
    Object.selectionForCompositeField "viewer" [] object_ (identity >> Decode.nullable)


{-| -}
writingSettings : SelectionSet decodesTo Wordpress.Object.WritingSettings -> SelectionSet (Maybe decodesTo) RootQuery
writingSettings object_ =
    Object.selectionForCompositeField "writingSettings" [] object_ (identity >> Decode.nullable)
